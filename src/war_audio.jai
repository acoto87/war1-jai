WarAudioId :: enum {
    Music00                 :: 0;
    Music01                 :: 1;
    Music02                 :: 2;
    Music03                 :: 3;
    Music04                 :: 4;
    Music05                 :: 5;
    Music06                 :: 6;
    Music07                 :: 7;
    Music08                 :: 8;
    Music09                 :: 9;
    Music10                 :: 10;
    Music11                 :: 11;
    Music12                 :: 12;
    Music13                 :: 13;
    Music14                 :: 14;
    Music15                 :: 15;
    Music16                 :: 16;
    Music17                 :: 17;
    Music18                 :: 18;
    Music19                 :: 19;
    Music20                 :: 20;
    Music21                 :: 21;
    Music22                 :: 22;
    Music23                 :: 23;
    Music24                 :: 24;
    Music25                 :: 25;
    Music26                 :: 26;
    Music27                 :: 27;
    Music28                 :: 28;
    Music29                 :: 29;
    Music30                 :: 30;
    Music31                 :: 31;
    Music32                 :: 32;
    Music33                 :: 33;
    Music34                 :: 34;
    Music35                 :: 35;
    Music36                 :: 36;
    Music37                 :: 37;
    Music38                 :: 38;
    Music39                 :: 39;
    Music40                 :: 40;
    Music41                 :: 41;
    Music42                 :: 42;
    Music43                 :: 43;
    Music44                 :: 44;
    Logo                    :: 472;
    IntroDoor               :: 473;
    Building                :: 474;
    Explosion               :: 475;
    CatapultRockFired       :: 476;
    TreeChopping1           :: 477;
    TreeChopping2           :: 478;
    TreeChopping3           :: 479;
    TreeChopping4           :: 480;
    BuildingCollapse1       :: 481;
    BuildingCollapse2       :: 482;
    BuildingCollapse3       :: 483;
    UIChime                 :: 484;
    UIClick                 :: 485;
    UICancel                :: 486;
    SwordAttack1            :: 487;
    SwordAttack2            :: 488;
    SwordAttack3            :: 489;
    FistAttack              :: 490;
    CatapultFireExplosion   :: 491;
    Fireball                :: 492;
    ArrowSpear              :: 493;
    ArrowSpearHit           :: 494;
    OrcHelp1                :: 495; // "The humans draw near"
    OrcHelp2                :: 496; // "The pale dogs approach"
    HumanHelp1              :: 497; // "The Orcs are approaching"
    HumanHelp2              :: 498; // "There are enemies nearby"
    OrcDead                 :: 499;
    HumanDead               :: 500;
    OrcWorkComplete         :: 501; // "Work completed"
    HumanWorkComplete       :: 502; // "Work completed"
    OrcHelp3                :: 503; // "We are being attacked"
    OrcHelp4                :: 504; // "They're destroying our city"
    HumanHelp3              :: 505; // "We are under attack"
    HumanHelp4              :: 506; // "The town is under attack"
    OrcReady                :: 507; // "Your command, master"
    HumanReady              :: 508; // "Your command"
    OrcAcknowledgement1     :: 509;
    OrcAcknowledgement2     :: 510;
    OrcAcknowledgement3     :: 511;
    OrcAcknowledgement4     :: 512;
    HumanAcknowledgement1   :: 513; // "Yes"
    HumanAcknowledgement2   :: 514; // "Yes, mylord"
    OrcSelected1            :: 515;
    OrcSelected2            :: 516;
    OrcSelected3            :: 517;
    OrcSelected4            :: 518;
    OrcSelected5            :: 519;
    HumanSelected1          :: 520; // "Yes?"
    HumanSelected2          :: 521; // "Your will, sire?"
    HumanSelected3          :: 522; // "Mylord?"
    HumanSelected4          :: 523; // "My liege?"
    HumanSelected5          :: 524; // "Your bidding?"
    OrcAnnoyed1             :: 525;
    OrcAnnoyed2             :: 526;
    OrcAnnoyed3             :: 527; // "Stop poking me"
    HumanAnnoyed1           :: 528; // "What?!"
    HumanAnnoyed2           :: 529; // "What do you want?!"
    HumanAnnoyed3           :: 530; // "Why do you keep touching me?!"
    DeadSpiderScorpion      :: 531;
    NormalSpell             :: 532;
    BuildRoad               :: 533;
    OrcTemple               :: 534;
    HumanChurch             :: 535;
    OrcKennel               :: 536;
    HumanStable             :: 537;
    Blacksmith              :: 538;
    FireCrackling           :: 539;
    Cannon1                 :: 540;
    Cannon2                 :: 541;
    CampaignsHumanEnding1   :: 542;
    CampaignsHumanEnding2   :: 543;
    CampaignsOrcEnding1     :: 544;
    CampaignsOrcEnding2     :: 545;
    Intro1                  :: 546; // "In the age of chaos..."
    Intro2                  :: 547; // "The kingdom of Azeroth was..."
    Intro3                  :: 548; // "No one knew where these..."
    Intro4                  :: 549; // "With an ingenious..."
    Intro5                  :: 550; // "Welcome to the World of Warcraft"
    CampaignsHumanIntro01   :: 551;
    CampaignsHumanIntro02   :: 552;
    CampaignsHumanIntro03   :: 553;
    CampaignsHumanIntro04   :: 554;
    CampaignsHumanIntro05   :: 555;
    CampaignsHumanIntro06   :: 556;
    CampaignsHumanIntro07   :: 557;
    CampaignsHumanIntro08   :: 558;
    CampaignsHumanIntro09   :: 559;
    CampaignsHumanIntro10   :: 560;
    CampaignsHumanIntro11   :: 561;
    CampaignsHumanIntro12   :: 562;
    CampaignsOrcIntro01     :: 563;
    CampaignsOrcIntro02     :: 564;
    CampaignsOrcIntro03     :: 565;
    CampaignsOrcIntro04     :: 566;
    CampaignsOrcIntro05     :: 567;
    CampaignsOrcIntro06     :: 568;
    CampaignsOrcIntro07     :: 569;
    CampaignsOrcIntro08     :: 570;
    CampaignsOrcIntro09     :: 571;
    CampaignsOrcIntro10     :: 572;
    CampaignsOrcIntro11     :: 573;
    CampaignsOrcIntro12     :: 574;
    HumanDefeat             :: 575; // "Your failure in battle"
    OrcDefeat               :: 576; // "You pitiful"
    OrcVictory1             :: 577; // "The feel of bones"
    OrcVictory2             :: 578; // "If only the worthless"
    OrcVictory3             :: 579; // "Gaze upon the destruction"
    HumanVictory1           :: 580; // "The forces of darkness"
    HumanVictory2           :: 581; // "Even these children"
    HumanVictory3           :: 582; // "Cheers of victory"
}

/**
 * Extension function of MemoryBuffer to read variable lengths integer values.
 */
mbReadUIntVar :: (buffer: *MemoryBuffer, value: *u32) -> bool {
    v: u32 = 0;
    byte: u8;
    for i : 0..4-1 {
        if (!mbRead(buffer, *byte)) {
            return false;
        }

        v = (v << 7) | cast(u32) (byte & 0x7F);
        if ((byte & 0x80) == 0) {
            break;
        }
    }
    <<value = v;
    return true;
}

/**
 * Extension function of MemoryBuffer to write variable lengths integer values.
 */
mbWriteUIntVar :: (buffer: *MemoryBuffer, value: u32) -> bool {
    byteCount: s32 = 1;
    v: u32 = value & 0x7F;
    value >>= 7;
    while (value > 0) {
        v = (v << 8) | 0x80 | (value & 0x7F);
        byteCount += 1;
        value >>= 7;
    }

    for i : 0..byteCount-1 {
        byte := cast(u8) (v & 0xFF);
        if (!mbWrite(buffer, byte)) {
            return false;
        }
        v >>= 8;
    }

    return true;
}

/**
 * This code is a port in C of the XMI2MID converter by Peter "Corsix" Cawley
 * in the War1gus repository. You can find the original C++ code here:
 * https://github.com/Wargus/war1gus/blob/master/xmi2mid.cpp.
 *
 * To understand more about these formats see:
 * http://www.shikadi.net/moddingwiki/XMI_Format
 * http://www.shikadi.net/moddingwiki/MID_Format
 * https://github.com/colxi/midi-parser-js/wiki/MIDI-File-Format-Specifications
 */
transcodeXmiToMid :: (xmiData: *u8, xmiLength: u32, midLength: *u32) -> *u8 {
    bufInput: MemoryBuffer;
    mbInitFromMemory(*bufInput, xmiData, xmiLength);

    bufOutput: MemoryBuffer;
    defer mbFree(*bufOutput);
    mbInitEmpty(*bufOutput);

    if (!mbScanTo(*bufInput, "EVNT", 4)) {
        return null;
    }

    if (!mbSkip(*bufInput, 8)) {
        return null;
    }

    lstTokens: List(MidiToken);
    init(*lstTokens);

    token: *MidiToken;
    tokenTime: s32 = 0;
    tempo: s32 = 500000;
    tempoSet := false;
    end := false;
    tokenType, extendedType: u8;
    intVar: u32;

    while (!mbIsEOF(*bufInput) && !end) {
        while (true) {
            if (!mbRead(*bufInput, *tokenType)) {
                return null;
            }

            if (tokenType & 0x80) {
                break;
            }

            tokenTime += cast(s32) tokenType * 3;
        }

        token = append(*lstTokens, tokenTime, tokenType);
        token.buffer = bufInput._pointer + 1;

        if (tokenType & 0xF0) == {
            case 0xC0; #through;
            case 0xD0; {
                if (!mbRead(*bufInput, *token.data)) {
                    return null;
                }

                token.buffer = null;
            }
            case 0x80; #through;
            case 0xA0; #through;
            case 0xB0; #through;
            case 0xE0; {
                if (!mbRead(*bufInput, *token.data)) {
                    return null;
                }

                if (!mbSkip(*bufInput, 1)) {
                    return null;
                }
            }
            case 0x90; {
                if (!mbRead(*bufInput, *extendedType)) {
                    return null;
                }

                token.data = extendedType;

                if (!mbSkip(*bufInput, 1)) {
                    return null;
                }

                if (!mbReadUIntVar(*bufInput, *intVar)) {
                    return null;
                }

                token = append(*lstTokens, tokenTime + cast(s32) intVar * 3, tokenType);
                token.data = extendedType;
                token.buffer = cast(*u8) 0;
            }
            case 0xF0; {
                extendedType = 0;

                if (tokenType == 0xFF) {
                    if (!mbRead(*bufInput, *extendedType)) {
                        return null;
                    }

                    if (extendedType == 0x2F) {
                        end = true;
                    } else if (extendedType == 0x51) {
                        if (!tempoSet) {
                            if (!mbSkip(*bufInput, 1)) {
                                return null;
                            }
                            if (!mbReadInt24BE(*bufInput, *tempo)) {
                                return null;
                            }
                            tempo *= 3;
                            tempoSet = true;
                            if (!mbSkip(*bufInput, -4)) {
                                return null;
                            }
                        } else {
                            removeAt(*lstTokens, lstTokens.count - 1);
                            if (!mbReadUIntVar(*bufInput, *intVar)) {
                                return null;
                            }
                            if (!mbSkip(*bufInput, intVar)) {
                                return null;
                            }
                            break;
                        }
                    }
                }

                token.data = extendedType;
                if (!mbReadUIntVar(*bufInput, *token.bufferLength)) {
                    return null;
                }
                token.buffer = bufInput._pointer;
                if (!mbSkip(*bufInput, token.bufferLength)) {
                    return null;
                }
            }
        }
    }

    if (lstTokens.count == 0) {
        return null;
    }
    if (!mbWriteString(*bufOutput, "MThd\0\0\0\x06\0\0\0\x01")) {
        return null;
    }
    if (!mbWriteUInt16BE(*bufOutput, cast(u16) ((tempo * 3) / 25000))) {
        return null;
    }
    if (!mbWriteString(*bufOutput, "MTrk\xBA\xAD\xF0\x0D")) {
        return null;
    }

    sort(*lstTokens, (left, right) => cast(s64) (left.time - right.time));

    tokenTime = 0;
    tokenType = 0;
    end = false;

    for t, i : lstTokens {
        if (end) {
            break;
        }

        if (!mbWriteUIntVar(*bufOutput, cast(u32) (t.time - tokenTime))) {
            return null;
        }

        tokenTime = t.time;

        if (t.type >= 0xF0) {
            tokenType = t.type;
            if (!mbWrite(*bufOutput, tokenType)) {
                return null;
            }

            if (tokenType == 0xFF) {
                if (!mbWrite(*bufOutput, t.data)) {
                    return null;
                }

                if (t.data == 0x2F) {
                    end = true;
                }
            }

            if (!mbWriteUIntVar(*bufOutput, t.bufferLength)) {
                return null;
            }
            if (!mbWriteBytes(*bufOutput, t.buffer, t.bufferLength)) {
                return null;
            }
        } else {
            if (t.type != tokenType) {
                tokenType = t.type;

                if (!mbWrite(*bufOutput, tokenType)) {
                    return null;
                }
            }

            if (!mbWrite(*bufOutput, t.data)) {
                return null;
            }

            if (t.buffer) {
                if (!mbWriteBytes(*bufOutput, t.buffer, 1)) {
                    return null;
                }
            }
        }
    }

    length: u32 = cast(u32) mbPosition(*bufOutput) - 22;
    if (!mbSeek(*bufOutput, 18)) {
        return null;
    }
    if (!mbWriteUInt32BE(*bufOutput, length)) {
        return null;
    }

    midLength64: s64;
    midData := mbGetData(*bufOutput, *midLength64);
    <<midLength = cast(u32) midLength64;
    return midData;
}

changeSampleRate :: (samplesIn: *u8, length: s32, factor: s32) -> *u8 {
    assert(factor >= 1);

    newLength := length * factor;
    samplesOut := alloc(u8, newLength);

    samplesOut[0] = samplesIn[0];

    j: s32 = 0;
    for i : 1..length-1 {
        a := samplesIn[i - 1];
        b := samplesIn[i];

        dt: f32 = 1.0 / factor;
        for k : 0..factor-2 {
            // linear interpolation: a + (b - a) * t
            t: f32 = dt * (k + 1);
            samplesOut[j] = cast(u8) (a + (b - a) * t);
            j += 1;
        }
        samplesOut[j] = b;
        j += 1;
    }

    return samplesOut;
}

#scope_file

MidiToken :: struct {
    time: s32;
    bufferLength: u32;
    buffer: *u8;
    type: u8;
    data: u8;
}

append :: (list: *List(MidiToken), time: s32, type: u8) -> *MidiToken {
    token: MidiToken;
    token.time = time;
    token.type = type;
    add(list, token);
    return *list.items[list.count - 1];
}